<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="fishbot_mid360">
  <xacro:arg name="config_file" default="$(find gazebo_sim)/robots/fishbot_mid360/config/fishbot_mid360.yaml"/>
  <xacro:property name="config_file" value="$(arg config_file)"/>

  <xacro:property name="cfg" value="${xacro.load_yaml(config_file)}"/>
  <xacro:property name="robot_cfg" value="${cfg['robot']}"/>
  <xacro:property name="geometry_cfg" value="${cfg['geometry']}"/>
  <xacro:property name="kinematics_cfg" value="${cfg['kinematics']}"/>
  <xacro:property name="plugins_cfg" value="${cfg['plugins']}"/>
  <xacro:property name="imu_cfg" value="${cfg['imu']}"/>
  <xacro:property name="lidar_cfg" value="${cfg['lidar']}"/>

  <xacro:property name="base_geom" value="${geometry_cfg['base']}"/>
  <xacro:property name="wheel_geom" value="${geometry_cfg['wheel']}"/>
  <xacro:property name="caster_geom" value="${geometry_cfg['caster']}"/>
  <xacro:property name="diff_drive_cfg" value="${plugins_cfg['diff_drive']}"/>

  <xacro:property name="base_frame" value="${robot_cfg['base_frame']}"/>
  <xacro:property name="lidar_frame" value="${robot_cfg['lidar_frame']}"/>
  <xacro:property name="imu_frame" value="${robot_cfg['imu_frame']}"/>

  <xacro:property name="odom_pub" value="${robot_cfg['odom_pub']}"/>
  <xacro:property name="lidar_pub" value="${robot_cfg['lidar_pub']}"/>
  <xacro:property name="imu_pub" value="${robot_cfg['imu_pub']}"/>

  <xacro:property name="wheel_radius" value="${wheel_geom['radius']}"/>
  <xacro:property name="wheel_length" value="${wheel_geom['length']}"/>
  <xacro:property name="wheel_inertia" value="${wheel_geom['inertia_diag']}"/>

  <xacro:property name="caster_radius" value="${caster_geom['radius']}"/>

  <xacro:property name="base_radius" value="${base_geom['cyl_radius']}"/>
  <xacro:property name="base_length" value="${base_geom['cyl_length']}"/>

  <xacro:property name="wheel_mass" value="${wheel_geom['mass']}"/>
  <xacro:property name="base_mass" value="${base_geom['mass']}"/>
  <xacro:property name="caster_mass" value="${caster_geom['mass']}"/>

  <xacro:property name="base_ixx" value="${base_geom['inertia']['ixx']}"/>
  <xacro:property name="base_iyy" value="${base_geom['inertia']['iyy']}"/>
  <xacro:property name="base_izz" value="${base_geom['inertia']['izz']}"/>

  <xacro:property name="wheel_sep" value="${kinematics_cfg['wheel_separation']}"/>
  <xacro:property name="wheel_diameter" value="${kinematics_cfg['wheel_diameter']}"/>

  <link name="base_footprint"/>

  <joint name="base_joint" type="fixed">
    <parent link="base_footprint"/>
    <child link="${base_frame}"/>
    <origin xyz="0.0 0.0 0.076" rpy="0 0 0"/>
  </joint>

  <link name="${base_frame}">
    <visual>
      <origin xyz="0 0 0.0" rpy="0 0 0"/>
      <geometry>
        <cylinder length="${base_length}" radius="${base_radius}"/>
      </geometry>
      <material name="blue">
        <color rgba="0.1 0.1 1.0 0.5"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 0.0" rpy="0 0 0"/>
      <geometry>
        <cylinder length="${base_length}" radius="${base_radius}"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="${base_mass}"/>
      <inertia ixx="${base_ixx}" ixy="0" ixz="0" iyy="${base_iyy}" iyz="0" izz="${base_izz}"/>
    </inertial>
  </link>

  <link name="${lidar_frame}">
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <cylinder length="0.02" radius="0.02"/>
      </geometry>
      <material name="black">
        <color rgba="0.0 0.0 0.0 0.5"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <cylinder length="0.02" radius="0.02"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="0.1"/>
      <inertia ixx="${wheel_inertia}" ixy="0" ixz="0" iyy="${wheel_inertia}" iyz="0" izz="${wheel_inertia}"/>
    </inertial>
  </link>

  <joint name="lidar_joint" type="fixed">
    <parent link="${base_frame}"/>
    <child link="${lidar_frame}"/>
    <origin xyz="0 0 0.075"/>
  </joint>

  <link name="${imu_frame}">
    <visual>
      <origin xyz="0 0 0.0" rpy="0 0 0"/>
      <geometry>
        <box size="0.02 0.02 0.02"/>
      </geometry>
    </visual>
    <collision>
      <origin xyz="0 0 0.0" rpy="0 0 0"/>
      <geometry>
        <box size="0.02 0.02 0.02"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="0.1"/>
      <inertia ixx="${wheel_inertia}" ixy="0" ixz="0" iyy="${wheel_inertia}" iyz="0" izz="${wheel_inertia}"/>
    </inertial>
  </link>

  <joint name="imu_joint" type="fixed">
    <parent link="${base_frame}"/>
    <child link="${imu_frame}"/>
    <origin xyz="0 0 0.02"/>
  </joint>

  <link name="left_wheel_link">
    <visual>
      <origin xyz="0 0 0" rpy="1.57079 0 0"/>
      <geometry>
        <cylinder length="${wheel_length}" radius="${wheel_radius}"/>
      </geometry>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="1.57079 0 0"/>
      <geometry>
        <cylinder length="${wheel_length}" radius="${wheel_radius}"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="${wheel_mass}"/>
      <inertia ixx="${wheel_inertia}" ixy="0" ixz="0" iyy="${wheel_inertia}" iyz="0" izz="${wheel_inertia}"/>
    </inertial>
  </link>

  <link name="right_wheel_link">
    <visual>
      <origin xyz="0 0 0" rpy="1.57079 0 0"/>
      <geometry>
        <cylinder length="${wheel_length}" radius="${wheel_radius}"/>
      </geometry>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="1.57079 0 0"/>
      <geometry>
        <cylinder length="${wheel_length}" radius="${wheel_radius}"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="${wheel_mass}"/>
      <inertia ixx="${wheel_inertia}" ixy="0" ixz="0" iyy="${wheel_inertia}" iyz="0" izz="${wheel_inertia}"/>
    </inertial>
  </link>

  <joint name="left_wheel_joint" type="continuous">
    <parent link="${base_frame}"/>
    <child link="left_wheel_link"/>
    <origin xyz="-0.02 0.10 -0.06"/>
    <axis xyz="0 1 0"/>
  </joint>

  <joint name="right_wheel_joint" type="continuous">
    <parent link="${base_frame}"/>
    <child link="right_wheel_link"/>
    <origin xyz="-0.02 -0.10 -0.06"/>
    <axis xyz="0 1 0"/>
  </joint>

  <link name="caster_link">
    <visual>
      <origin xyz="0 0 0" rpy="1.57079 0 0"/>
      <geometry>
        <sphere radius="${caster_radius}"/>
      </geometry>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="1.57079 0 0"/>
      <geometry>
        <sphere radius="${caster_radius}"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="${caster_mass}"/>
      <inertia ixx="${wheel_inertia}" ixy="0" ixz="0" iyy="${wheel_inertia}" iyz="0" izz="${wheel_inertia}"/>
    </inertial>
  </link>

  <joint name="caster_joint" type="fixed">
    <parent link="${base_frame}"/>
    <child link="caster_link"/>
    <origin xyz="0.06 0.0 -0.076"/>
    <axis xyz="0 1 0"/>
  </joint>

  <gazebo reference="caster_link">
    <material>Gazebo/Black</material>
  </gazebo>

  <gazebo reference="caster_link">
    <mu1 value="0.0"/>
    <mu2 value="0.0"/>
    <kp value="1000000.0"/>
    <kd value="10.0"/>
  </gazebo>

  <gazebo>
    <plugin name="diff_drive" filename="libgazebo_ros_diff_drive.so">
      <ros>
        <remapping>cmd_vel:=cmd_vel</remapping>
        <remapping>odom:=${odom_pub}</remapping>
      </ros>
      <update_rate>${diff_drive_cfg['update_rate']}</update_rate>
      <left_joint>left_wheel_joint</left_joint>
      <right_joint>right_wheel_joint</right_joint>
      <wheel_separation>${wheel_sep}</wheel_separation>
      <wheel_diameter>${wheel_diameter}</wheel_diameter>
      <max_wheel_torque>${diff_drive_cfg['max_wheel_torque']}</max_wheel_torque>
      <max_wheel_acceleration>${diff_drive_cfg['max_wheel_accel']}</max_wheel_acceleration>
      <publish_odom>${'true' if diff_drive_cfg['publish_odom'] else 'false'}</publish_odom>
      <publish_odom_tf>${'true' if diff_drive_cfg['publish_odom_tf'] else 'false'}</publish_odom_tf>
      <publish_wheel_tf>${'true' if diff_drive_cfg['publish_wheel_tf'] else 'false'}</publish_wheel_tf>
      <odometry_frame>odom</odometry_frame>
      <robot_base_frame>${base_frame}</robot_base_frame>
    </plugin>
  </gazebo>

  <gazebo reference="${imu_frame}">
    <sensor name="imu_sensor" type="imu">
      <plugin filename="libgazebo_ros_imu_sensor.so" name="imu_plugin">
        <ros>
          <remapping>~/out:=${imu_pub}</remapping>
        </ros>
        <initial_orientation_as_reference>false</initial_orientation_as_reference>
      </plugin>
      <always_on>true</always_on>
      <update_rate>${imu_cfg['update_rate']}</update_rate>
      <visualize>${'true' if imu_cfg['visualize'] else 'false'}</visualize>
      <imu>
        <angular_velocity>
          <x>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>${imu_cfg['noise']['ang_stddev']}</stddev>
              <bias_mean>${imu_cfg['noise']['ang_bias_mean']}</bias_mean>
              <bias_stddev>${imu_cfg['noise']['ang_bias_stddev']}</bias_stddev>
            </noise>
          </x>
          <y>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>${imu_cfg['noise']['ang_stddev']}</stddev>
              <bias_mean>${imu_cfg['noise']['ang_bias_mean']}</bias_mean>
              <bias_stddev>${imu_cfg['noise']['ang_bias_stddev']}</bias_stddev>
            </noise>
          </y>
          <z>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>${imu_cfg['noise']['ang_stddev']}</stddev>
              <bias_mean>${imu_cfg['noise']['ang_bias_mean']}</bias_mean>
              <bias_stddev>${imu_cfg['noise']['ang_bias_stddev']}</bias_stddev>
            </noise>
          </z>
        </angular_velocity>
        <linear_acceleration>
          <x>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>${imu_cfg['noise']['lin_stddev']}</stddev>
              <bias_mean>${imu_cfg['noise']['lin_bias_mean']}</bias_mean>
              <bias_stddev>${imu_cfg['noise']['lin_bias_stddev']}</bias_stddev>
            </noise>
          </x>
          <y>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>${imu_cfg['noise']['lin_stddev']}</stddev>
              <bias_mean>${imu_cfg['noise']['lin_bias_mean']}</bias_mean>
              <bias_stddev>${imu_cfg['noise']['lin_bias_stddev']}</bias_stddev>
            </noise>
          </y>
          <z>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>${imu_cfg['noise']['lin_stddev']}</stddev>
              <bias_mean>${imu_cfg['noise']['lin_bias_mean']}</bias_mean>
              <bias_stddev>${imu_cfg['noise']['lin_bias_stddev']}</bias_stddev>
            </noise>
          </z>
        </linear_acceleration>
      </imu>
    </sensor>
  </gazebo>

  <gazebo reference="${lidar_frame}">
    <sensor name="lidar_sensor" type="ray">
      <always_on>true</always_on>
      <visualize>${'true' if lidar_cfg['visualize'] else 'false'}</visualize>
      <update_rate>${lidar_cfg['update_rate']}</update_rate>
      <pose>0 0 0.075 0 0 0</pose>
      <ray>
        <scan>
          <horizontal>
            <samples>${lidar_cfg['h_rays']['samples']}</samples>
            <resolution>${lidar_cfg['h_rays']['resolution']}</resolution>
            <min_angle>${lidar_cfg['h_rays']['min_angle']}</min_angle>
            <max_angle>${lidar_cfg['h_rays']['max_angle']}</max_angle>
          </horizontal>
          <vertical>
            <samples>${lidar_cfg['v_rays']['samples']}</samples>
            <resolution>${lidar_cfg['v_rays']['resolution']}</resolution>
            <min_angle>${lidar_cfg['v_rays']['min_angle']}</min_angle>
            <max_angle>${lidar_cfg['v_rays']['max_angle']}</max_angle>
          </vertical>
        </scan>
        <range>
          <min>${lidar_cfg['range_min']}</min>
          <max>${lidar_cfg['range_max']}</max>
          <resolution>${lidar_cfg['range_res']}</resolution>
        </range>
        <noise>
          <type>gaussian</type>
          <mean>0.0</mean>
          <stddev>${lidar_cfg['noise_stddev']}</stddev>
        </noise>
      </ray>
      <plugin name="lidar_plugin" filename="libgazebo_ros_ray_sensor.so">
        <ros>
          <remapping>~/out:=${lidar_pub}</remapping>
        </ros>
        <output_type>sensor_msgs/PointCloud2</output_type>
        <frame_name>${lidar_frame}</frame_name>
      </plugin>
    </sensor>
  </gazebo>

</robot>
